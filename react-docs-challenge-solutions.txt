NOTE:

All previous challenges were simply enough that I did not care to paste my solutions in here.

============================================================================================================

PASSING-PROPS-TO-A-COMPONENT    CHALLENGE 1

import { getImageUrl } from './utils.js';

// Extracted component Profile
function Profile({ name, imgID, profession, award, awardDescription, discovery }){
  return (
    <>
      <h2>{name}</h2>
      <img 
        className="avatar"
        src={getImageUrl(imgID)}
        alt={name}
        width={70}
        height={70}
      />
      <ul>
        <li>
          <b>Profession: </b>
          {profession}
        </li>
        <li>
          <b>Awards: {award} </b>
          {awardDescription}
        </li>
        <li>
          <b>Discovererd: </b>
          {discovery}
        </li>
      </ul>
    </>
  );
}

export default function Gallery() {
  return (
    <div>
      <h1>Notable Scientists</h1>
      <section className="profile">
      <Profile 
        name="Maria Skłodowska-Curie"
        imgID="szV5sdG"
        profession="physicist and chemist"
        award="4"
        awardDescription="(Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)"
        discovery="polonium (element)" />
      </section>
      <section className="profile">
      <Profile 
        name="Katsuko Saruhashi"
        imgID="YfeOqp2"
        profession="geochemist"
        award="2"
        awardDescription="(Miyake Prize for geochemistry, Tanaka Prize)"
        discovery="a method for measuring carbon dioxide in seawater" />
      </section>
    </div>
  );
}

============================================================================================================

PASSING-PROPS-TO-A-COMPONENT    CHALLENGE 2

import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  // Evaluate image size
  let imgSize = size < 90 ? 's' : 'b';
  return (
    <img
      className="avatar"
      src={getImageUrl(person, imgSize)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <Avatar
      size={40}a
      person={{ 
        name: 'Gregorio Y. Zara', 
        imageId: '7vQD0fP'
      }}
    />
  );
}

============================================================================================================

PASSING-PROPS-TO-A-COMPONENT    CHALLENGE 3

// Extraced as component Card
function Card ({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

export default function Profile() {
  return (
    <div>
      <Card>
        <div className="card-content">
          <h1>Photo</h1>
          <img
            className="avatar"
            src="https://i.imgur.com/OKS67lhm.jpg"
            alt="Aklilu Lemma"
            width={70}
            height={70}
          />
        </div>
      </Card>
      <Card>
        <div className="card-content">
          <h1>About</h1>
          <p>Aklilu Lemma was a distinguished Ethiopian scientist who discovered a natural treatment to schistosomiasis.</p>
        </div>
      </Card>
    </div>
  );
}


============================================================================================================
============================================================================================================

CONDITIONAL-RENDERING    CHALLENGE 1

function Item({ name, isPacked }) {
  return (
    <li className="item">
      // Ternary operator is used
      {name} {isPacked ? '✔' : '❌'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

============================================================================================================

CONDITIONAL-RENDERING    CHALLENGE 2

function Item({ name, importance }) {
  return (
    <li className="item">
    // A JS variable is nested inside a litearl string inside the JS opening in JSX
      {name} <i>{importance > 0 && `(Importance: ${importance})`}</i>
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          importance={9} 
          name="Space suit" 
        />
        <Item 
          importance={0} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          importance={6} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

============================================================================================================

CONDITIONAL-RENDERING    CHALLENGE 3

function Info({ drinkDetails }) {
  return (
    <dl>
      <dt>Part of plant</dt>
      <dd>{drinkDetails.partOfPlant}</dd>
      <dt>Caffeine content</dt>
      <dd>{drinkDetails.caffeineContent}</dd>
      <dt>Age</dt>
      <dd>{drinkDetails.age}</dd>
    </dl>
  );
}

function Drink({ name }) {
  let drink = {};
  if (name === 'tea') {
    drink.partOfPlant = 'leaf',
    drink.caffeineContent = '15–70 mg/cup',
    drink.age = '4,000+ years'
  } else {
    drink.partOfPlant = 'bean',
    drink.caffeineContent = '80–185 mg/cup',
    drink.age = '1,000+ years'
  }
  return (
    <section>
      <h1>{name}</h1>
      <Info
        drinkDetails = {drink} />
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}


// My solution includes some repetition, definitely still room to improve.
//
// Official solution uses object for each type of drinks, then nest them 
// in an object containing all types of drinks. 

============================================================================================================
============================================================================================================


RENDERING-LISTS    CHALLENGE 1

DATA

export const people = [{
  id: 0,
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}, {
  id: 1,
  name: 'Mario José Molina-Pasquel Henríquez',
  profession: 'chemist',
  accomplishment: 'discovery of Arctic ozone hole',
  imageId: 'mynHUSa'
}, {
  id: 2,
  name: 'Mohammad Abdus Salam',
  profession: 'physicist',
  accomplishment: 'electromagnetism theory',
  imageId: 'bE7W1ji'
}, {
  id: 3,
  name: 'Percy Lavon Julian',
  profession: 'chemist',
  accomplishment: 'pioneering cortisone drugs, steroids and birth control pills',
  imageId: 'IOjWm71'
}, {
  id: 4,
  name: 'Subrahmanyan Chandrasekhar',
  profession: 'astrophysicist',
  accomplishment: 'white dwarf star mass calculations',
  imageId: 'lrWQx8l'
}];

CODE

import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const chemists = people.filter(person => person.profession === 'chemist');
  const scientists = people.filter(person => person.profession !== 'chemist');

  const chemistListItems = chemists.map(chemist =>
    <li key={chemist.id}>
      <img
        src={getImageUrl(chemist)}
        alt={chemist.name}
      />
      <p>
        <b>{chemist.name}:</b>
        {' ' + chemist.profession + ' '}
        known for {chemist.accomplishment}
      </p>
    </li>
  );
  const remainingListItems = scientists.map(scientist =>
    <li key={scientist.id}>
      <img
        src={getImageUrl(scientist)}
        alt={scientist.name}
      />
      <p>
        <b>{scientist.name}:</b>
        {' ' + scientist.profession + ' '}
        known for {scientist.accomplishment}
      </p>
    </li>
  );  
  return (
    <article>
      <h1>Chemists</h1>
      <ul>{chemistListItems}</ul>
      <h1>Scientists</h1>
      <ul>{remainingListItems}</ul>
    </article>
  );
}


NOTE: ABOVE WAS MY INITIAL SOLUTION, WHERE filter() WAS CALLED TWICE, CHECK THE 
      OFFICIAL SOLUTION BELOW WHICH HAS LESS DUPLICATION

import { people } from './data.js';
import { getImageUrl } from './utils.js';

let chemists = [];
let everyoneElse = [];
people.forEach(person => {
  if (person.profession === 'chemist') {
    chemists.push(person);
  } else {
    everyoneElse.push(person);
  }
});

// Map provided people array, and generate <li> with each array element using .map()
function CreateList({ title, people }) {
  return (
    <>
      <h2>{title}</h2>
      <ul>
        {
          // Here .map() is called without assignment, so a new array is created 
          and immediately used rendered
          people.map(person => {
            <li key={person.id}>
              <img
                src={getImageUrl(person)}
                alt={person.name}
              />
              <p>
                <b>{person.name}:</b>
                {' ' + person.profession + ' '}
                known for {person.accomplishment}
              </p>
            </li>
          })
        }
      </ul>
    </>
  );
}

export default function List() {
  return (
    <article>
      <h1>Scientists</h1>
      <ListSection
        title="Chemists"
        people={chemists}
      />
      <ListSection
        title="Everyone Else"
        people={everyoneElse}
      />
    </article>    
  );
}


============================================================================================================


RENDERING-LISTS    CHALLENGE 2

DATA

export const recipes = [{
  id: 'greek-salad',
  name: 'Greek Salad',
  ingredients: ['tomatoes', 'cucumber', 'onion', 'olives', 'feta']
}, {
  id: 'hawaiian-pizza',
  name: 'Hawaiian Pizza',
  ingredients: ['pizza crust', 'pizza sauce', 'mozzarella', 'ham', 'pineapple']
}, {
  id: 'hummus',
  name: 'Hummus',
  ingredients: ['chickpeas', 'olive oil', 'garlic cloves', 'lemon', 'tahini']
}];


CODE

import { recipes } from './data.js';

// Two nested .map() calls
function List({ recipes }){
  return(
    <>
      {
        recipes.map(recipe =>
          <ul>
            <li key={recipe.id}>
              <h2>{recipe.name}</h2>
              <ul>
                {
                  recipe.ingredients.map((ingredient, index) => 
                    <li key={index}>{ingredient}</li>
                  )
                }
              </ul>
            </li>
          </ul>
        )
      }
    </>
  );
}

export default function RecipeList() {
  return (
    <div>
      <List
      recipes={recipes} />
    </div>
  );
}


============================================================================================================


RENDERING-LISTS    CHALLENGE 3

import { recipes } from './data.js';

function Recipe({ id, name, ingredients }) {
  return (
    <div>
      <h2>{name}</h2>
      <ul>
        {ingredients.map(ingredient =>
          <li key={ingredient}>
            {ingredient}
          </li>
        )}
      </ul>
    </div>
  );
}

export default function RecipeList() {
  return (
    <div>
      <h1>Recipes</h1>
      {recipes.map(recipe =>
        <Recipe 
        key={recipe.id}
        id={recipe.id}
        name={recipe.name}
        ingredients={recipe.ingredients}
        />
      )}
    </div>
  );
}


============================================================================================================


RENDERING-LISTS    CHALLENGE 4

const poem = {
  lines: [
    'I write, erase, rewrite',
    'Erase again, and then',
    'A poppy blooms.'
  ]
};

export default function Poem() {
  return (
    <article>
      {poem.lines.map((line, index) =>
      <>
        <p key={index}>
          {line}
        </p>
        {
          (index != poem.lines.length - 1) && <hr />
        }
      </>
      )}
    </article>
  );
}


============================================================================================================


KEEPIGN-COMPONENTS-PURE    CHALLENGE 1

export default function Clock({ time }) {
  let hours = time.getHours();
  return (
    <>
      {
        if (hours >= 0 && hours <= 6) {
          <h1 id="time" class="night">
            {time.toLocaleTimeString()}
          </h1>
        } else {
          <h1 id="time" class="day">
            {time.toLocaleTimeString()}
          </h1>
        }
      }
    </>
  );
}

export default function Clock({ time }) {
  let hours = time.getHours();
  return (
    <>
      {}
    </>
  );
}


NOTE: I WAS UNABLE TO SOLVE THIS CHALLENGE BECAUSE I DID NOT KNOW THAT:

  (1) CONDITIONAL STATEMENTS (IF-ELSE, ETC) ARE **NOT** ALLOWED IN RETURN STATEMENTS 
      (BUT TERNARY, && AND OTHER **EXPRESSIONS** ARE OK)
  (2) CONDITIONALLY RENDERING CAN BE DONE BY SETTING `className` ATTRIBUTE, **NOT**
      `class` BECAUSE IT IS A RESERVED KEYWORD


I REFERRED TO THE FOLLOWING OFFICIAL SOLUTION.

export default function Clock({ time }) {
  let hours = time.getHours();
  let className;
  if (hours >= 0 && hours <= 6) {
    className = 'night';
  } else {
    className = 'day';
  }
  return (
    <h1 
    id="time"
    className={className}
    >
      {time.toLocaleTimeString()}
    </h1>
  );
}


============================================================================================================


KEEPIGN-COMPONENTS-PURE    CHALLENGE 2

Profile.js:

import Panel from './Panel.js';
import { getImageUrl } from './utils.js';

export default function Profile({ person }) {
  return (
    <Panel>
      <Header 
      person={person}/>
      <Avatar 
      person={person}/>
    </Panel>
  )
}

function Header({ person }) {
  return <h1>{person.name}</h1>;
}

function Avatar({ person }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={50}
      height={50}
    />
  );
}

App.js:

import Profile from './Profile.js';

export default function App() {
  return (
    <>
      <Profile person={{
        imageId: 'lrWQx8l',
        name: 'Subrahmanyan Chandrasekhar',
      }} />
      <Profile person={{
        imageId: 'MK3eW3A',
        name: 'Creola Katherine Johnson',
      }} />
    </>
  )
}


============================================================================================================


KEEPIGN-COMPONENTS-PURE    CHALLENGE 3

export default function StoryTray({ stories }) {
  let story = {
    id: 'create',
    label: 'Create Story'
  };

  stories.push(story);

  return (
    <ul>
      <li key={story.id}>
        {story.label}
      </li>
    </ul>
  );
}

NOTE: I ALSO FAILED TO COMPLETE THIS CHALLENGE BECUASE I COULD NOT UNDERSTAND THE PURPOSE OF .map(). AS
      IT TURNED OUT, .map() IS USED TO DISPLAY ITEMS ALREADY STORED IN THE ARRAY. 

I LEARNT:
  (1) PROPS ARE NOT TO BE ALTERED. SO WHILE IT'S OKAY TO .map() AND DISPLAY ALREADY STORED ITEMS, TEMPLATE
      ITEMS MUST NOT BE .push()'D INTO THE ARRAY, BUT RATHER RENDERED DIRECTLY.
  (2) .slice() CAN BE USED TO DUPLICATE ARRAYS.

OFFICAL SOLUTION:

export default function StoryTray({ stories }) {
  return (
    <ul>
      {stories.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
      <li>Create Story</li>
    </ul>
  );
}


============================================================================================================


RESPONDING-TO-EVENTS    CHALLENGE 1

export default function LightSwitch() {
  function handleClick() {
    let bodyStyle = document.body.style;
    if (bodyStyle.backgroundColor === 'black') {
      bodyStyle.backgroundColor = 'white';
    } else {
      bodyStyle.backgroundColor = 'black';
    }
  }

  return (
    <button onClick={handleClick}>
      Toggle the lights
    </button>
  );
}


============================================================================================================


RESPONDING-TO-EVENTS    CHALLENGE 2

export default function ColorSwitch({
  onChangeColor
}) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onChangeColor();
    }}>
      Change color
    </button>
  );
}


============================================================================================================


STATE-A-COMPONENTS-MEMORY    CHALLENGE 1

App.js

import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  //[ben, john, louis, nelson]
  // 0, 1, 2, 3
  // 4

  let hasNext = index < sculptureList.length - 1;
  let hasPrev = index > 0;

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handlePrevClick() {
    setIndex(index - 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button 
      onClick={handleNextClick}
      disabled={!hasPrev}
      >
        Prev
      </button>    
      <button 
      onClick={handleNextClick}
      disabled={!hasNext}
      >
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}

NOTE: I WASN'T ABLE OT COMPLETE THIS CHALLENGE WITHOUT LOOKING AT THE SOLUTION, BECAUSE:

  (1) I DID NOT KNOW HOW TO DISABLE A BUTTON (I THOUGHT ABOUT `disabled` IS A STANDALONE
      KEYWORD IN HTML <button> TAG, NOT THAT IT CAN BE USED AS BOOLEAN EXPRESSION)
  (2) I DID NOT KNOW ABOUT THE ELEGANT WAY OF USING AN EXPRESSION TO INITIALIZE VARIABLES


============================================================================================================


STATE-A-COMPONENTS-MEMORY    CHALLENGE 2

import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  function handleReset() {
    setFirstName('');
    setLastName('');
  }

  return (
    <form onSubmit={e => e.preventDefault()}>
      <input
        placeholder="First name"
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder="Last name"
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>Hi, {firstName} {lastName}</h1>
      <button onClick={handleReset}>Reset</button>
    </form>
  );
}


============================================================================================================


STATE-A-COMPONENTS-MEMORY    CHALLENGE 3

import { useState } from 'react';

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('');

  if (isSent) {
    return <h1>Thank you!</h1>;
  } else {
    // eslint-disable-next-line
    return (
      <form onSubmit={e => {
        e.preventDefault();
        alert(`Sending: "${message}"`);
        setIsSent(true);
      }}>
        <textarea
          placeholder="Message"
          value={message}
          onChange={e => setMessage(e.target.value)}
        />
        <br />
        <button type="submit">Send</button>
      </form>
    );
  }
}


============================================================================================================


STATE-A-COMPONENTS-MEMORY    CHALLENGE 4

export default function FeedbackForm() {

  function handleClick() {
    let name = prompt('What is your name?');
    alert(`Hello, ${name}!`);
  }

  return (
    <button onClick={handleClick}>
      Greet
    </button>
  );
}


============================================================================================================


STATE-AS-A-SNAPSHOT    CHALLENGE 1

import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    const alertText = walk ? 'Stop is next' : 'Walk is next';
    setWalk(!walk);
    alert(alertText);
  }

  return (
    <>
      <button onClick={handleClick}>
        Change to {walk ? 'Stop' : 'Walk'}
      </button>
      <h1 style={{
        color: walk ? 'darkgreen' : 'darkred'
      }}>
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}


============================================================================================================


QUEUING-A-SERIES-OF-STAE-UPDATES    CHALLENGE 1

import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);  // 0 + 1
    await delay(3000);
    setPending(pending - 1);  // 0 - 1 <--- THIS GETS EXECUTED
    setCompleted(completed + 1);  // 0 + 1 <--- THIS GETS EXECUTED
  }

  return (
    <>
      <h3>
        Pending: {pending}
      </h3>
      <h3>
        Completed: {completed}
      </h3>
      <button onClick={handleClick}>
        Buy     
      </button>
    </>
  );
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

NOTE: UNABLE TO COMPLETE THIS DUE TO UNFAMILIARITY WITH UPDATER FUNCTIONS.

I LEARNT:
  (1) UPDATER FUNCTIONS ARE ACTIVE THROUGHOUT THE ENTIRE HANDLER

import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>
        Pending: {pending}
      </h3>
      <h3>
        Completed: {completed}
      </h3>
      <button onClick={handleClick}>
        Buy     
      </button>
    </>
  );
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}


============================================================================================================


QUEUING-A-SERIES-OF-STAE-UPDATES    CHALLENGE 2

export function getFinalState(baseState, queue) {
  let finalState = baseState;
  
  for (let update of queue) {
    if (typeof update === 'function'){
      finalState = update(finalState);
    }
    else {
      finalState = update;
    }
  }

  return finalState;
}


============================================================================================================


UPDATING-OBJECTS-IN-STATE    CHALLENGE 1

import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    let newScore = player.score + 1;   // WAS 'player.score++'
    setPlayer({
      ...player,
      score: newScore
    })
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      ...player,
      lastName: e.target.value
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>
        {' '}
        <button onClick={handlePlusClick}>
          +1
        </button>
      </label>
      <label>
        First name:
        <input
          value={player.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={player.lastName}
          onChange={handleLastNameChange}
        />
      </label>
    </>
  );
}

NOTE: THIS WAS INTEREST BECAUSE I INITIALLY WAS NOT ABLE TO SOVLE IT BECUASE I FORGOT THAT
      ++newScore AND newScore++ RETURN **DIFFERENT** THING. I USED LATTER SO EVERYTIME IT
      RETURNED VALUE BEFORE INCREMENT, HENCE RESULTING IN UNCHANGED VALUE.


============================================================================================================

** GOOD CHALLENGE **
// THIS CLEARS CONCEPTS ABOUT NESTING OBJECTS AND REFERENCING

UPDATING-OBJECTS-IN-STATE    CHALLENGE 2

import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

** ORIGINAL PROBLEM **
// Background changes as color changes
  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }
// Since shape.position refers to the `initialPosition` object, mutating it
// would mean changing the object that it is referring to, i.e. `initialPosition`.

** MY ATTEMPT **
// Background follows cursor
function handleMove(dx, dy) {
  setShape({
    ...shape,
    position: {
      ...shape.initialPosition,
      x: initialPosition.x += dx,
      y: initialPosition.y += dy
    }
  });
}
// This essentially makes a copy of the original `initialPosition`, changes it and 
// retain shape.position's reference to `initialPosition`. So any changes made to
// the coordinates is immediately reflected in position of background.


// ** SOLUTION **
function handleMove(dx, dy) {
  setShape({
    ...shape,
    position: {
      x: shape.position.x + dx,
      y: shape.position.y + dy,
    }
  });
}
// Notice spread operator is **NOT** used in position. This means `initialPosition` is never
// copied and carried over to the new object. Instead, fresh .x and .y properties are 
// defined on the spot with dx and dy.

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition}
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        Drag me!
      </Box>
    </>
  );
}

NOTE: AGAIN, UNABLE TO SOVLE. LOOK AT handleMove() LOGICS, I WAS NOT ABLE TO IDENTIFY += AS MUTATION.


THE FOLLLOWING ARE CODES THAT IMPLEMENT DRAG AND DROP. IT'S INTERESTING SO I'M PUTTING IT HERE.

import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >{children}</div>
  );
}


============================================================================================================


UPDATING-OBJECTS-IN-STATE    CHALLENGE 3

import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, updateShape] = useImmer({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    updateShape(draft => {
      draft.position.x += dx;
      draft.position.y += dy; // Notice how `+=` is mutation and not allowed in regular React
    });
  }

  function handleColorChange(e) {
    updateShape(draft => {
      draft.color = e.target.value;
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition}
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        Drag me!
      </Box>
    </>
  );
}


============================================================================================================


UPDATING-ARRAYS-IN-STATE    CHALLENGE 1

import { useState } from 'react';

const initialProducts = [{
  id: 0,
  name: 'Baklava',
  count: 1,
}, {
  id: 1,
  name: 'Cheese',
  count: 5,
}, {
  id: 2,
  name: 'Spaghetti',
  count: 2,
}];

export default function ShoppingCart() {
  const [
    products,
    setProducts
  ] = useState(initialProducts)

  function handleIncreaseClick(productId) {
    setProducts(products.map(product => {
      if (product.id === productId) {
        let newCount = product.count + 1;
        return { ...product, count: newCount};
      } else {
        return product;
      }
    }));
  }

  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>
          {product.name}
          {' '}
          (<b>{product.count}</b>)
          <button onClick={() => {
            handleIncreaseClick(product.id);
          }}>
            +
          </button>
        </li>
      ))}
    </ul>
  );
}


============================================================================================================


UPDATING-ARRAYS-IN-STATE    CHALLENGE 2

import { useState } from 'react';

const initialProducts = [{
  id: 0,
  name: 'Baklava',
  count: 1,
}, {
  id: 1,
  name: 'Cheese',
  count: 5,
}, {
  id: 2,
  name: 'Spaghetti',
  count: 2,
}];

export default function ShoppingCart() {
  const [
    products,
    setProducts
  ] = useState(initialProducts)

  function handleIncreaseClick(productId) {
    setProducts(products.map(product => {
      if (product.id === productId) {
        return {
          ...product,
          count: product.count + 1
        };
      } else {
        return product;
      }
    }));
  }


// .filter() is first used before .map(), which is used to filter out
// products that have count of one. Pressing '-' deletes them (not being
// included)
  function handleDecreaseClick(productId) {
    setProducts(products.filter(product =>
      product.count > 1
    ).map(product => {
      if (product.id === productId) {
        return {
          ...product,
          count: product.count - 1
        };
      } else {
        return product;
      }
    }));
  }

  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>
          {product.name}
          {' '}
          (<b>{product.count}</b>)
          <button onClick={() => {
            handleIncreaseClick(product.id);
          }}>
            +
          </button>
          <button onClick={() => {
            handleDecreaseClick(product.id);
          }}>
            –
          </button>
        </li>
      ))}
    </ul>
  );
}


============================================================================================================


UPDATING-ARRAYS-IN-STATE    CHALLENGE 3

import { useState } from 'react';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Buy milk', done: true },
  { id: 1, title: 'Eat tacos', done: false },
  { id: 2, title: 'Brew tea', done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAddTodo(title) {
    setTodos(
      [...todos, {id: nextId++, title: title, done: false}]
      );
  }

  // Alter an item in an array
  // .map() is used to iteratively consider each item, and apply
  // modification with spread operator and new information
  function handleChangeTodo(nextTodo) {
    setTodos(todos.map(todo => {
      if (todo.id === nextTodo.id) {
        return {...todo, title: nextTodo.title, done: nextTodo.done};
      } else {
        return todo;
      }
    }));
  }

  function handleDeleteTodo(todoId) {
    setTodos(todos.filter(todo =>
      todo.id !== todoId
    ));
  }

  return (
    <>
      <AddTodo
        onAddTodo={handleAddTodo}
      />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}


updateMyTodos(draft => {
  const artwork = draft.find(a => a.id === artworkId);
  artwork.seen = nextSeen;
});


============================================================================================================


UPDATING-ARRAYS-IN-STATE    CHALLENGE 4

import { useImmer } from 'use-immer';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Buy milk', done: true },
  { id: 1, title: 'Eat tacos', done: false },
  { id: 2, title: 'Brew tea', done: false },
];

export default function TaskApp() {
  const [todos, updateTodos] = useImmer(
    initialTodos
  );

  function handleAddTodo(title) {
    updateTodos(draft => {
      draft.push({
        id: nextId++,
        title: title,
        done: false  
      })
    });
  }

  function handleChangeTodo(nextTodo) {
    updateTodos(draft => {
      // Note: The reason 'draft' does not appear anymore is
      // becuase by looping over and assigning 't' to 'todo', 
      // you are essentially changing draft itself.
      const todo = draft.find(t =>
        t.id === nextTodo.id
      );
      todo.title = nextTodo.title;
      todo.done = nextTodo.done;
    });
  }

  function handleDeleteTodo(todoId) {
    updateTodos(draft => {
      const index = draft.findIndex(t =>
          t.id === todoId
        );
      draft.splice(index, 1);
    })
  }

  return (
    <>
      <AddTodo
        onAddTodo={handleAddTodo}
      />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}

NOTE: I PASED SOLUTION WHICH MIXED IMMER AND NON-MUTATIVE METHODS:

import { useState } from 'react';
import { useImmer } from 'use-immer';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

let nextId = 3;
const initialTodos = [
  { id: 0, title: 'Buy milk', done: true },
  { id: 1, title: 'Eat tacos', done: false },
  { id: 2, title: 'Brew tea', done: false },
];

export default function TaskApp() {
  const [todos, updateTodos] = useImmer(
    initialTodos
  );

  function handleAddTodo(title) {
    updateTodos(draft => {
      draft.push({
        id: nextId++,
        title: title,
        done: false
      });
    });
  }


  // Notice the use of .map() here
  function handleChangeTodo(nextTodo) {
    updateTodos(todos.map(todo => {
      if (todo.id === nextTodo.id) {
        return nextTodo;
      } else {
        return todo;
      }
    }));
  }

  // Use of .filter() here as well
  function handleDeleteTodo(todoId) {
    updateTodos(
      todos.filter(t => t.id !== todoId)
    );
  }

  return (
    <>
      <AddTodo
        onAddTodo={handleAddTodo}
      />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
